    //collision
    public boolean colliding(Positioned other) {
        //großen test mit rechtecken ausführen
        Double a = new Double(getPosition().x + getShape().getRelativePosition().x, getPosition().y + getShape().getRelativePosition().y);
        Double b = new Double(a.x + getShape().getWidth(), a.y);
        Double c = new Double(a.x + getShape().getWidth(), a.y + getShape().getHeight());
        Double d = new Double(a.x, a.y + getShape().getHeight());

        Double e = new Double(other.getPosition().x + other.getShape().getRelativePosition().x, other.getPosition().y + other.getShape().getRelativePosition().y);
        Double f = new Double(e.x + other.getShape().getWidth(), e.y);
        Double g = new Double(e.x + other.getShape().getWidth(), e.y + other.getShape().getHeight());
        Double h = new Double(e.x, e.y + other.getShape().getHeight());

        if(!Functionality.rectsColliding(a, b, c, d, e, f, g, h)) return false;

        //dann für alle squares wie ein volidiot überprüfen ob sie kollidieren, aufwand ist ja nur n2...
        int scale = getShape().getScale();
        Double translation = getShape().getRelativePosition();
        int otherScale = other.getShape().getScale();
        Double otherTranslation = other.getShape().getRelativePosition();
        for(Square square : getShape().getSquares()) {
            double x = square.x * scale + translation.x + getPosition().x;
            double y = square.y * scale + translation.y + getPosition().y;

            Double first = new Double(x, y);
            Double second = new Double(x + scale - 1, y);
            Double third = new Double(x + scale - 1, y + scale - 1);
            Double fourth = new Double(x, y + scale - 1);

            for(Square otherSquare : other.getShape().getSquares()) {
                double otherX = otherSquare.x * otherScale + otherTranslation.x + other.getPosition().x;
                double otherY = otherSquare.y * otherScale + otherTranslation.y + other.getPosition().y;

                Double otherFirst = new Double(otherX, otherY);
                Double otherSecond = new Double(otherX + otherScale - 1, otherY);
                Double otherThird = new Double(otherX + otherScale - 1, otherY + otherScale - 1);
                Double otherFourth = new Double(otherX, otherY + otherScale - 1);

                if(Functionality.rectsColliding(first, second, third, fourth, otherFirst, otherSecond, otherThird, otherFourth)) return true;
            }
        }
        return false;
    }

    ^
    |
    |
    Für Positioned. War unnötig da es sich als zu kompliziert und auch unnötig herausgestellt hat, mit den Kollisionen irgendwas anzufangen


        //für sicht erstmal
    public ArrayList<Positioned> searchRayPrecise(Double position, double angle, double distance) {
        double heightAtStart = position.y - getVerticalCell(position.y) * Options.cellLength;
        double distanceCounterXY = position.x - getHorizontalCell(position.x) * Options.cellLength;
        double distanceCounter = 0;
        double xPosInCell = 0; 
        double yPosInCell = 0;
        int horizontalBoundsCounter = getHorizontalCell(position.x);
        int verticalBoundsCounter = getVerticalCell(position.y);
        boolean xyAngleSwitch = false; // true bedeutet delta y != 1 false bedeutet x != 1
        boolean firstIntersect = true; // nach dem 1. Intersect bleibt die Distanz konstant, der Wert beim 1. Intersect ist Positionsabhängig
        boolean isPiOverFour = false; // 45 Grad?
        boolean straightLine = false; // Gerade Linie?
        int angleCaseSwitchX = 0; // Regelt in welche Richtung sich die Sicht ausbreitet
        int angleCaseSwitchY = 0; // Regelt in welche Richtung sich die Sicht ausbreitet in Sonderfällen

        if(Math.cos(angle) == 0 || Math.sin(angle) == 0){ // Regelt Vorzeichen der Rechnung
            angleCaseSwitchX = (int) Math.cos(angle);
            angleCaseSwitchY = (int) Math.sin(angle);
            straightLine = true;

        } else{
            angleCaseSwitchX = (int) (Math.cos(angle) / Math.abs(Math.cos(angle)));
            angleCaseSwitchY = (int) (Math.sin(angle) / Math.abs(Math.sin(angle)));
            if(Math.abs(Math.cos(angle)) == Math.abs(Math.sin(angle))){
                isPiOverFour = true;
            } else if(Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))){
                xyAngleSwitch = false;
                distanceCounterXY = position.x - getHorizontalCell(position.x) * Options.cellLength;
                heightAtStart = position.y - getVerticalCell(position.y) * Options.cellLength;
            } else{
                xyAngleSwitch = true;
                distanceCounterXY = position.y - getVerticalCell(position.y) * Options.cellLength;
                heightAtStart = position.x - getHorizontalCell(position.x) * Options.cellLength;
            }
        } 

        
        if(xyAngleSwitch){
            if(angleCaseSwitchX == 1){
                xPosInCell = Options.cellLength - heightAtStart;
            } else if(angleCaseSwitchX == -1){
                xPosInCell = heightAtStart;
                if(!xyAngleSwitch) distanceCounterXY = Options.cellLength - distanceCounterXY;
            } 
            if(angleCaseSwitchY == 1){
                yPosInCell = Options.cellLength - distanceCounterXY;
            } else if(angleCaseSwitchY == -1){
                yPosInCell = distanceCounterXY;
                if(xyAngleSwitch) distanceCounterXY = Options.cellLength - distanceCounterXY;
            } 
        } else{
            if(angleCaseSwitchX == 1){
                xPosInCell = Options.cellLength - distanceCounterXY;
            } else if(angleCaseSwitchX == -1){
                xPosInCell = distanceCounterXY;
                if(!xyAngleSwitch) distanceCounterXY = Options.cellLength - distanceCounterXY;
            } 
            if(angleCaseSwitchY == 1){
                yPosInCell = Options.cellLength - heightAtStart;
            } else if(angleCaseSwitchY == -1){
                yPosInCell = heightAtStart;
                if(xyAngleSwitch) distanceCounterXY = Options.cellLength - distanceCounterXY;
            } 
        }
        
        ArrayList<Positioned> relevant = new ArrayList<>();

        while((distanceCounter < distance) && (horizontalBoundsCounter >= 0) && (horizontalBoundsCounter < amountOfHorizontalCells) && (verticalBoundsCounter >= 0) && (verticalBoundsCounter < amountOfVerticalCells)){
            if(distanceCounter >= distance) break;
            if(isPiOverFour == true){
                if(firstIntersect == true){
                    distanceCounter += Math.sqrt(Math.pow((xPosInCell), 2) + Math.pow(yPosInCell, 2));
                    firstIntersect = false;
                } else{
                    distanceCounter += Math.sqrt(Math.pow(Options.cellLength, 2) * 2);
                }
                horizontalBoundsCounter += angleCaseSwitchX;
                if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                    relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                }
                verticalBoundsCounter += angleCaseSwitchY;
                if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                    relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                }
            } else if(straightLine == true){
                if(firstIntersect == true){
                    distanceCounter += (xPosInCell) * Math.abs(angleCaseSwitchX);
                    distanceCounter += (yPosInCell) * Math.abs(angleCaseSwitchY);
                    firstIntersect = false;
                } else{
                    distanceCounter+= Options.cellLength;
                }
                horizontalBoundsCounter += angleCaseSwitchX;
                verticalBoundsCounter += angleCaseSwitchY;
                if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                    relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                }
            }else if(xyAngleSwitch == true){
                if(firstIntersect == true){
                    distanceCounter += Math.sqrt(Math.pow((xPosInCell / Math.tan(angle)), 2) + Math.pow(xPosInCell, 2));
                    distanceCounterXY += (xPosInCell / Math.tan(angle));
                    firstIntersect = false;
                } else{
                    distanceCounter += Math.sqrt(Math.pow((Options.cellLength / Math.tan(angle)), 2) + Options.cellLength);
                    distanceCounterXY += Options.cellLength / Math.tan(angle);
                }
                if(distanceCounterXY >= Options.cellLength){
                    distanceCounterXY-= Options.cellLength;
                    horizontalBoundsCounter += angleCaseSwitchX;
                    if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                        relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                    }
                }
                verticalBoundsCounter += angleCaseSwitchY;
                if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                    relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                }
            } else{
                if(firstIntersect == true){
                    distanceCounter += Math.sqrt(Math.pow((yPosInCell / Math.tan(angle)), 2) + Math.pow(yPosInCell, 2));
                    distanceCounterXY += (yPosInCell / Math.tan(angle));
                    firstIntersect = false;
                } else{
                    distanceCounter += Math.sqrt(Math.pow((Options.cellLength / Math.tan(angle)), 2) + Options.cellLength);
                    distanceCounterXY += Options.cellLength / Math.tan(angle);
                }
                if(distanceCounterXY >= Options.cellLength){
                    distanceCounterXY-= Options.cellLength;
                    verticalBoundsCounter += angleCaseSwitchY;
                    if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                        relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                    }
                }
                horizontalBoundsCounter += angleCaseSwitchX;
                if(horizontalBoundsCounter >= 0 && horizontalBoundsCounter < amountOfHorizontalCells && verticalBoundsCounter >= 0 && verticalBoundsCounter < amountOfVerticalCells){
                    relevant.addAll(contents.get(horizontalBoundsCounter).get(verticalBoundsCounter));
                }
            }
        }
        return relevant;
    }

    ^
    |
    |
    präzisere Methode, um Zellen mit einem Strahl zu durchsuchen. Hat aber nicht funktioniert
