    //collision
    public boolean colliding(Positioned other) {
        //großen test mit rechtecken ausführen
        Double a = new Double(getPosition().x + getShape().getRelativePosition().x, getPosition().y + getShape().getRelativePosition().y);
        Double b = new Double(a.x + getShape().getWidth(), a.y);
        Double c = new Double(a.x + getShape().getWidth(), a.y + getShape().getHeight());
        Double d = new Double(a.x, a.y + getShape().getHeight());

        Double e = new Double(other.getPosition().x + other.getShape().getRelativePosition().x, other.getPosition().y + other.getShape().getRelativePosition().y);
        Double f = new Double(e.x + other.getShape().getWidth(), e.y);
        Double g = new Double(e.x + other.getShape().getWidth(), e.y + other.getShape().getHeight());
        Double h = new Double(e.x, e.y + other.getShape().getHeight());

        if(!Functionality.rectsColliding(a, b, c, d, e, f, g, h)) return false;

        //dann für alle squares wie ein volidiot überprüfen ob sie kollidieren, aufwand ist ja nur n2...
        int scale = getShape().getScale();
        Double translation = getShape().getRelativePosition();
        int otherScale = other.getShape().getScale();
        Double otherTranslation = other.getShape().getRelativePosition();
        for(Square square : getShape().getSquares()) {
            double x = square.x * scale + translation.x + getPosition().x;
            double y = square.y * scale + translation.y + getPosition().y;

            Double first = new Double(x, y);
            Double second = new Double(x + scale - 1, y);
            Double third = new Double(x + scale - 1, y + scale - 1);
            Double fourth = new Double(x, y + scale - 1);

            for(Square otherSquare : other.getShape().getSquares()) {
                double otherX = otherSquare.x * otherScale + otherTranslation.x + other.getPosition().x;
                double otherY = otherSquare.y * otherScale + otherTranslation.y + other.getPosition().y;

                Double otherFirst = new Double(otherX, otherY);
                Double otherSecond = new Double(otherX + otherScale - 1, otherY);
                Double otherThird = new Double(otherX + otherScale - 1, otherY + otherScale - 1);
                Double otherFourth = new Double(otherX, otherY + otherScale - 1);

                if(Functionality.rectsColliding(first, second, third, fourth, otherFirst, otherSecond, otherThird, otherFourth)) return true;
            }
        }
        return false;
    }

    ^
    |
    |
    Für Positioned. War unnötig da es sich als zu kompliziert und auch unnötig herausgestellt hat, mit den Kollisionen irgendwas anzufangen